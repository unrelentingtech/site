+++
date = 2017-01-06T17:11:39+00:00
path = "/replies/2017-01-06-17-11-39"

[extra]
client_id = ["https://micropublish.herokuapp.com"]

[[extra.in_reply_to]]
name = "Lifestream Architecture"
published = 2015-06-15T04:00:00+00:00
type = "entry"
updated = 2015-06-15T00:00:00+00:00
url = "https://chromic.org/blog/lifestream-architecture/"

[extra.in_reply_to.content]
text = "Recently, the homepage of this blog changed from\n    a static list of recent blog posts to a realtime stream of updates (the list\n    of blog posts is still there, moved to the sidebar). This post tries to\n    document (mostly as a \"note-to-self\", again) how this \"lifestream\" works.\n\n  Note: This is a work-in-progress; I've already got plans to tweak how some\n    of the pieces fit together.\n\n\nAn overview of the pieces used to build the update stream.\n    Description follows.\n\nTL;DR\n\nMy sources are PuSH publishers, I have a PuSH hub running on the server,\n  the lifestream is a PuSH subscriber.\n\nDetails\n\nFor this project, I have three requirements:\n\nRealtime: I want the updates to appear in realtime. No polling.\n    To acheive this, we rely on the\n    Pubsubhubbub\n    (PuSH) protocol.\n  Self-hosted: Everything needs to run on a machine/VM I own/rent (most\n    of this stuff is on a Linode)\n  Open Source / Free Software: Everything I run needs to be F(L)OSS\n\nIf we refer to the image above, the information flows from left to right, with\n  the exception of the dashed line which we'll talk about a bit later.\n\nPushing Updates (PuSH publishers)\n\nThe Blog\n\nThe Blog is the most \"manual\" source at the moment. It runs on\n  Jekyll and to publish a post, I push to my\n  git repository on my Gogs instance\n  (more information about this setup here).\n\nAfter the new post has been published, I run a bash one-liner script that\n  pings the PuSH hub:\n\n#!/usr/bin/bash\n\ncurl -d hub.mode=publish -d \"hub.url=http://chromic.org/feed.xml\" http://push.chromic.org\n\nYes, I do plan on automating this at some point.\n\nMedia\n\nI run GNU mediagoblin as a media\n  publishing platform. It's PuSH-enabled out-of-the-box so I don't have to do\n  much here. I did, however, modify the Atom Feed generated by gmg so that it\n  includes a direct link to the media file (so that I can include it in the\n  lifestream).\n\nCode\n\nI run Gogs on code.chromic.org. This one is the\n  most hacky-cobbled-together source in the lifestream (so far!). Ultimately,\n  I'd like to have the\n  public activity events\n  pushed to the stream, but right now only \"git-push\" events are sent over.\n  There are a couple of reasons for this:\n\nGogs isn't PuSH-enabled so I need to ping the hub myself\n  Gogs is written in Go, which is a compiled language, which means I can't just\n    open files and tweak them. And, I've been too lazy to setup a Go/Gogs\n    development environment so far.\n\nGiven this situation, I have to use the features Gogs support out-of-the-book.\n  Luckily, Gogs supports webhooks on git-push events. You can probably see where\n  this is going: I've setup all my repository to execute a PHP script whenever\n  I push code:\n\n&lt;?php\nrequire_once('../../_config.php');\n\n$gogs = $config['gogs'];\n$data = file_get_contents('php://input');\n\n// Invalid payloadtry {\n    $json = json_decode($data);\n} catch (Exception $e) {\n    header($_SERVER['SERVER_PROTOCOL'] . ' 400 Bad Request');\n    exit;\n}\n\n// Invalid 'secret'if ($gogs['secret'] !== $json-&gt;secret) {\n    header($_SERVER['SERVER_PROTOCOL'] . ' 400 Bad Request');\n    exit;\n}\n\n$ch = curl_init($gogs['push']);\ncurl_setopt($ch, CURLOPT_USERAGENT, 'gogs webhook script');\ncurl_setopt($ch, CURLOPT_HEADER, false);\ncurl_setopt($ch, CURLOPT_POST, true);\ncurl_setopt($ch, CURLOPT_POSTFIELDS, 'hub.mode=publish&amp;hub.url=' . $gogs['topic']);\n$ok = curl_exec($ch);\ncurl_close($ch);\n\nif (!$ok) {\n    error_log('Could not ping hub (errno: ' . curl_errno($ch) . ')', 4);\n    error_log('Curl error message: ' . curl_error($ch) ,4);\n} else {\n    error_log('Pinged hub successfully');\n}\n\nThis is also on the \"to improve\" list.\n\nMicroblog\n\nThis one is also easy. I use GNU social as a\n  microblogging platform. It's PuSH-enabled out-of-the-box. I don't need to do\n  anything here.\n\nNote: There are a couple of event types that aren't PuSH'ed (e.g.: favorites)\n  by the GNU social platform.\n\nFm\n\nI added a small curl snippet to /nixtape/1.x/submissions/1.2/index.php\n  and /gnukebox/submissions/1.2/index.php to ping the hub anytime I scrobble\n  anything.\n\nThe Hubs\n\nI run an unmodified instance of\n  Switchboard as a PuSH\n  hub. This is where the PuSH publishers send the \"ping\" whenever they publish\n  something, with the exception of GNU social.\n\nGNU social, in addition to being a PuSH-publisher out-of-the-box, has its own\n  built-in PuSH hub.\n\nThe Subscriber\n\nI wrote a quick NodeJS \"app\"\n  that subscribes to the publishers above through the Switchboard Hub or the GNU\n  social hub. When it recieves notification from the hub that content has been\n  published, it fetches the feed/page it's subscribed to (this is the dashed\n  line in the image above), gets the latest update, parses it and saves the data\n  to a database.\n\nIt also notifies the lifestream of new events through websockets.\n\nThe Lifestream\n\nFinally, we have the\n  lifestream\n  which is a simple PHP script that gets previously saved events from the MySQL\n  database, and new events through websockets.\n\nConclusion\n\nI'm planning on adding more sources to the stream as time goes by. Polishing how\n  everything works is also an ongoing activity."

+++

<p>You have an interesting setup â€“ looks like a blog with Webmention support, but GNU social for the microblog. Have you enabled the Linkback plugin on your GNU social instance? It seems to support Webmentions!</p>